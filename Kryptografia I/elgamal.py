p = 6262263371377541559141206895621884814807915303145516042650825916222136098970293814810224532254572606923485012865464653542596037422501455912488470111758490086095137370045391054577237580171284636282615725496568360590261691887179088064684821943355507214597667739684622993519703639685862165456606534344947
x = -1831848944654438578680931843323781967581951359544432469465859793716377126588722692849486241121314279763178719116053330559415007978747231329088425724769619907558118568416619870417918752065421786996731037566984329764120000127110604671799692639001148712141410776812882409354267203252047876023101514203171
c1 = 4930490882687076116085929823448518556524926336621082524571007069499319395855324296502235437445967934932787521600599107532531078194796843391952627184815516623257150401617528223084265470741645331148385802788497019587076927091538268120958170365588158668012464348961057111168929144800733802189147469833339
c2 = 1320778616639746095525730330254407469921408577233897503987468020505370909557234769852635541377723891236681125391568276272644732373241015100686633081535309319866887351174142276504736818002775011538657454525452322932342497332733737438842353481743010298952515756561095990344099481063406400709632171512866

import re
import timeit

def fast_exp(b, e, m):
    r = 1
    if 1 & e:
        r = b
    while e:
        e >>= 1
        b = (b * b) % m
        if e & 1: r = (r * b) % m
    return r

def binary(x, k, n):
    k = bin(k)
    k = re.sub(r'^0b', '', k)

    y = 1
    l = len(k)
    i = 0

    while i < l:
        y = (y * y) % n
        if k[i] == '1':
            y = (y * x) % n
        i = i + 1

    return y

def euclidean(N, x):
    A = N
    B = x
    U = 0
    V = 1

    while True:
        q = A // B

        tempA = B
        tempB = A - q * B
        A = tempA
        B = tempB

        new_U = V
        new_V = U - q * V
        U = new_U
        V = new_V

        if B == 0:
            d = A
            u = U
            v = (d - x * u) // N
            return (d, u, v)


def inverse(number, modulo):
    result = 0
    e = euclidean(modulo, number)
    if e[0] != 1:
        print("No inverse")
        return result
    else:
        result = (e[1] % modulo + modulo) % modulo
        return result

def descrypt(c1,c2,p,x):
    c1_inverse = inverse(c1, p)
    c1_pow = binary(c1_inverse, x, p)
    n = (c2 * c1_pow) % p
    return n


start = timeit.default_timer()
n = descrypt(c1, c2, p, x)
stop = timeit.default_timer()
print("Ukryta wiadomoÅ›Ä‡ to: ", n)
print("Completed in time: {}".format(stop - start))